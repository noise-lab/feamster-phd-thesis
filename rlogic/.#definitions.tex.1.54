\section{Preliminaries: Paths, Routes, and Policy}\label{sec:definitions}

Before introducing the correctness properties themselves, we first
introduce some basic terminology for routing.  We explain these terms in
the context of Internet routing and BGP.  We first define paths and
routes in terms of a graph $G = (V,E)$, where the nodes in $V = \{v_1,
\ldots, v_N\}$ correspond to IP-level nodes (\ie, routers and end hosts)
and the edges in $E$ corresponds to IP-level links between those nodes.

\subsection{Paths and Routes}

We now define two basic terms---path and route---and explain their
relation to one another.  We first define these terms generally.  Then,
we discuss them using Internet routing as an example.

\begin{defn}[Path]
A {\em path} is a sequence of nodes $P = (v_0, \ldots, v_n)$, where $v_i
\in G$ for all $0 \leq i \leq n$.
\end{defn}
\noindent

The definition of a path does not constrain how the sequence of nodes is
actually constructed.  As such, a path might represent a sequence of
directly connected IP-layer nodes, endpoints of a tunnel, or even
AS-level hops.  Note that deleting nodes from a path still results in a
path.  For example, a path that is a sequence of tunnel endpoints can be
constructed by taking the corresponding IP-layer path and deleting all
nodes but the tunnel endpoints.

A path between two nodes is simply a sequence of nodes in the graph,
$G$.  A route, on the other hand, is {\em information} that allows
nodes in $G$ to construct paths to destinations.  The purpose of a
routing protocol is to propagate routes to nodes in $G$.  Collectively,
the routes to $d$ that the nodes in $G$ ultimately select define the
{\em path} from any node in $G$ to that destination.

\begin{defn}[Route]\label{def:route}
A {\em route} is a mapping $(d \rightarrow v_i)$, where $d$ is a
destination, and $v_i \in G$ is the node en route to the destination
$d$.  
\end{defn}
\noindent
The {\em destination} $d$ may either refer to a single node or a group
of nodes.  We say that $v_i\in d$ if the destination $d$ refers to
$v_i$.  A route $(d \rightarrow v_i)$ received by $v_j$ indicates that,
if $v_j$ has data to send to some node at destination $d$, it can send
it to $v_i$, which will in turn will have a route to $d$ (whereupon this
process repeats until the data reaches $d$).  One can think of a route
$(d \rightarrow v_i)$ being used at node $v_j$ as a {\em path segment},
$v_j, \ldots, v_i$, where either $v_j$ and $v_i$ are directly connected or the
actual nodes along that path segment are determined by the lower-layer
connectivity (\ie, as established by the IGP, tunnels, etc.)

Note that Definition~\ref{def:route} can apply to any routing protocol,
not just to BGP.  In an IGP, the $v_i$ is typically the a router that is
immediately connected at the IP layer.  In BGP, however, (particularly
in iBGP) the next hop may in fact be several IP-layer hops away.  In
BGP, a node that receives a route $(d \rightarrow v)$ but is not
directly connected to $v$ must rely on the IGP for reachability to $v$.
We now briefly discuss paths and routes in the context of BGP.

\subsubsection{Example: Paths and Routes in Internet Routing}

To illustrate the distinction between routes and paths, we examine their
definitions within the context of BGP routing within a single AS.  In
this case, a {\em route} is of the form $(d \rightarrow v_i)$, where $d$
is an IP prefix and $v_i$ is the BGP ``next hop'' (a node that need not
be directly connected at the IP layer).  The {\em path} that traffic
takes from some node $v_j$ to the destination $d$, for which it has a
route $(d \rightarrow v_i)$, depends on how connectivity is established
between $v_j$ and $v_i$.  If $v_j$ and $v_i$ are in two different ASes,
then they are typically directly connected.  If they are in the same AS,
however, it is common for $v_i$ to be the IP address of an egress (or
``border'') router and for $v_j$ to be several IP hops away.  The path
between $v_j$ and $v_i$ may be determined by a tunnel, by a shortest
paths routing protocol, static routes, and so forth.

If the path segment is not defined by a tunnel, then the nodes between
$v_j$ and $v_i$ may also have BGP routes to $d$.  In this case, the
actual path to $d$ is actually determined by ``stitching together''
these lower layer paths.  If all nodes between $v_j$ and $v_i$ select
routes that indicate that traffic to $d$ should be sent via $v_i$, then
the path between $v_j$ and $v_i$ is defined by the lower layer protocol
(\eg, an IGP).  Otherwise, the path could be arbitrary; in fact, it
might never traverse $v_i$.

\begin{figure}
\centering
\begin{psfrags}
\psfrag{v1}{{\LARGE $v_1$}}
\psfrag{v2}{{\LARGE $v_2$}}
\psfrag{v3}{{\LARGE $v_3$}}
\psfrag{v4}{{\LARGE $v_4$}}
\psfrag{v5}{{\LARGE $v_5$}}
\psfrag{d}{{\LARGE $d$}}
\psfrag{dr}{{\Large $(d \rightarrow v_5)$}}
%
%\hspace{-0.7in}
\resizebox{0.65\textwidth}{!}{\includegraphics{rlogic/figures/path_route.eps}}
\end{psfrags}
%\epsfig{file=policy/figures/dw.eps,width=0.28\textwidth}
\caption[Paths and routes in BGP.]{An example illustrating the distinction of
  paths and routes in BGP.  Dashed lines are iBGP sessions from route
  reflector to client (\ie, $v_3$ is a route reflector, and the rest of
  the routers are its clients).  Solid lines show IGP links; in this
  example, all links have a cost of $1$.}
\label{fig:path_route}
\end{figure}

Figure~\ref{fig:path_route} shows an example that illustrates this
distinction.  In this example, all routers in the AS are clients of the
route reflector, $v_3$; solid lines show the edges in the IGP graph, and
all edges have a cost of $1$.  Suppose that $v_3$ learns two routes to
$d$ and selects the route that it receives from $v_5$.  In this case,
$v_3$ propagates that {\em route} (\ie, $(d \rightarrow v_5)$) to all of
its clients, as shown.   Using that route, each node ultimately uses a
different {\em path} to the egress router, $v_5$.  For example, $v_1$'s
shortest IGP path to $v_5$ is $v_1,v_3,v_5$, whereas $v_2$'s shortest
path to $v_5$ is $v_2, v_5$.  Even if a node, say $v_1$ selects a BGP
route with the ``next hop'' $v_5$, there is no guarantee that the
resulting {\em path} will traverse $v_5$.  If an additional node, $v_6$
had been on the path between $v_1$ and $v_3$, and had instead selected a
route $(d\rightarrow v_4)$, then $v_1$'s path to $d$ through the AS
could have in fact been $v_1, v_6, v_4$.




%For the pursposes of our work, we assume that physical
%links and internal routing is operating correctly.  That is, we assume
%that a path exists between {\em any} source-destination pair where the
%source and destination are in the same AS.

\subsection{Policy}

A noteworthy aspect of Internet routing is that it is policy-based.
That is, the job of the routing protocol is not to propagate complete
information about the topology, but to only propagate information about
paths that comply with the various economic and policy goals of each AS.
Towards this goal, we must qualify paths in the topology according to
those that comply with such these policies and those that do not.

\begin{defn}[Policy]
A {\em policy} is a function $\P(v_{i-1},v_{i},v_{i+1},d) \rightarrow (0,1)$,
where $v_{i-1}$, $v_i$, and $v_{i+1}$ are 
nodes and $d$ is a destination, and $\P$ is defined as follows:
\[
\P(v_{i-1},v_i,v_{i+1},d) = \left\{\
\begin{array}{l}
1\textrm{ if $i=0$ and $v_0$ carries traffic destined for $d$}\\
1\textrm{ if $0<i<n$ and $v_i$ carries traffic from $v_{i-1}$ destined for $d$}\\
1\textrm{ if $i=n$ and $v_n$ carries traffic destined for $d$}\\
0\textrm{ otherwise }
\end{array}
\right.
\]
\end{defn}

The function $\P(v_{i-1}, v_i, v_{i+1}, d)$ is not expressive enough to
capture all policies, but, as we will see, it is general enough to
capture the the policies that are commonly expressed in Internet
routing.  Other routing systems may in fact require more expressive
policy functions. Our intention here is not to define a policy function
that captures all policies, but rather to allow us to define a
policy-conformant path in the context of Internet routing.

%A value of $0$ indicates that traffic
%should not be allowed to flow on any path from $s$ to $d$; a value of
%$1$ indicates that such a path is permissible.

\begin{defn}[Policy-conformant path]
A path $v_0, v_1, v_2, \ldots, v_n, d$ is policy-conformant if
$\P(v_{i-1}, v_i, v_{i+1},d) = 1$ for all $0 \leq i \leq n$.  
\end{defn}

\noindent
For Internet routing, we assume that paths for which the source,
destination, and all nodes in between the source and destination are in
the same AS are policy-conformant.  
%

\begin{figure}
\centering
\begin{psfrags}
\psfrag{vx}{$v_X$}
\psfrag{vy1}{$v_i$}
\psfrag{vy2}{$v_j$}
\psfrag{vz}{$v_Z$}
\resizebox{0.9\textwidth}{!}{\includegraphics{rlogic/figures/policy_ex.eps}}
\end{psfrags}
\caption[Expressing policy-conformant paths in BGP.]{An example
  illustrating policy-conformant paths in BGP.}
\label{fig:policy_ex}
\end{figure}


The policy function $\P$ allows an operator to restrict paths that do
not conform to some policy by expressing $\P(v_{i-1},v_i,v_{i+1},d)$,
where $v_{i-1}$, $v_i$, and $v_{i+1}$ are nodes in three different ASes.
Although the policy function is defined at the level of nodes, it is in
fact expressive enough to capture many AS-level policies that network
operators commonly want to express.  Suppose an operator wants to
express that AS $Y$ should not carry traffic between two other ASes, $X$
and $Z$ for some destination $d$ (\ie, that no path to $d$ through the
sequence of ASes $X$, $Y$, and $Z$ is policy-conformant), as pictured in
Figure~\ref{fig:policy_ex}.  Recall that a path with some nodes removed
still constitutes a path.  As such, it is possible for an to express
this policy according to the nodes in the ASes $X$ and $Z$ along the
path.  For example, in this example, the policy can be expressed as
$\P(v_X, v_i, v_Z, d) = 0$.  In a more complicated scenario, AS $Y$
might have multiple nodes that are adjacent to nodes in ASes $X$ and
$Z$; in this case, the AS-level policy could still be expressed as an
enumeration of node-level policies.


\section{Route Validity}\label{sec:validity_def}

In this section, we motivate and describe {\em route validity}.
Informally, route validity says that any route that
the routing protocol propagates should correspond to an actual path in the
topology.  We now define route validity more formally and discuss its
definition in the context of BGP.

\begin{defn}[Route validity]
A routing protocol satisfies {\em route validity} if, for any node $v_0$
and destination $d$, for all routes $r: (d\rightarrow v_i)$ at $v_0$,
there exists a policy-conformant path $(v_0, v_1 \ldots, v_i, \ldots,
v_n, d)$, such that:
\begin{enumerate}
\itemsep=-1pt
\item all nodes on the path segment $(v_0, \ldots, v_{i-1})$ select the
  route $(d \rightarrow v_i)$
\item the path segment $(v_0, \ldots, v_{i-1})$ is policy-conformant
\item if $v_i \not\in d$, then $v_i$ selects a valid route to $d$
\end{enumerate}
\end{defn}


\begin{figure}
\centering
\begin{psfrags}
%\epsfig{file=policy/figures/lemdr.eps,width=0.25\textwidth}
%
\psfrag{vi}{ $v_i$}
\psfrag{vi1}{$v_{i-1}$}
\psfrag{v0}{$v_0$}
\psfrag{v1}{$v_1$}
\psfrag{dr}{$(d \rightarrow v_i)$}
\psfrag{d}{$d$}
%
%\hspace{-0.7in}
\resizebox{0.85\textwidth}{!}{\includegraphics{rlogic/figures/rv_expl.eps}}
\end{psfrags}
%\epsfig{file=policy/figures/dw.eps,width=0.28\textwidth}
\caption[The three conditions of route validity.]{The three conditions
  of route validity.} 
\label{fig:rv_expl}
\end{figure}


Figure~\ref{fig:rv_expl} explains the three conditions of route validity
in more detail.  The first condition of route validity enforces
consistency along the path between $v_0$ and the node $v_i$ towards
which $v_0$ sends traffic en route to $d$. If all intermediate nodes
between $v_0$ and $v_i$ have the same next-hop, $v_i$, then there can be
no forwarding loops between $v_0$ and $v_i$.  Furthermore, the path from
$v_0$ to $v_i$ must be policy-conformant; that is, every node along the
path $v_0, \ldots, v_i$ must carry traffic from its predecessor to its
next hop en route to $d$.  Although, as previously mentioned, most paths
within an AS are policy conformant, verifying policy conformance is
rather difficult for paths that traverse multiple ASes, because
operators do not explicitly specify the policy function $\P$.  The final
condition of route validity says that, once traffic reaches the node
$v_i$, then that node also has a route to the destination that satisfies
route validity.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Because a source $v_0$ and a destination $d$ may be in different ASes,
guaranteeing that BGP satisfies route validity is difficult in practice
because it requires knowledge of the configurations of multiple ASes.
Fortunately, route validity is composable: we now show that if the
routing protocols in each AS en route to a destination satisfy route
validity, then BGP will satisfy route validity.  For now, we assume that
all paths are policy-conformant, since detecting violations of policy
are hard to verify in practice; we will return to this issue in
Section~\ref{sec:validity}.  We also assume that all eBGP sessions are
point-to-point (\ie, immediately connected at the IP layer), which is
almost always the case in practice.

\begin{theorem}\label{thm:composable}
If for every AS, iBGP satisfies route validity, and all paths are
policy-conformant, then BGP satisfies satisfies route validity globally.
\end{theorem}

\begin{proof}
We must show that, when a route gives rise to a path where any $v_i$ and
$v_{i+1}$ are in different ASes, then the path that traverses the two
ASes still satisfies the conditions for route validity.  Since the path
segment $v_i, v_{i+1}$ is a point-to-point link, then $v_i$ selects the
route $(d \rightarrow v_{i+1})$, and the first condition is satisfied.
The third condition is satisfied by the inductive assumption.  
\end{proof}

\noindent
Thus, modulo policy conformance, guaranteeing that BGP satisfies route
validity boils down to ensuring that iBGP satisfies route validity
within each AS.  Guaranteeing that iBGP satisfies route validity is the
focus of the remainder of this section.  We first focus on route
validity for ``full mesh'' iBGP configurations, before turning to route
validity for iBGP configurations that use route reflection.

\subsection{Full mesh iBGP configurations}

If different routers within an AS receive different sets of candidate
routes to some destination $d$, then the routers along a path from $v_0$
to $v_i$ may not ultimately select the route $(d \rightarrow v_i)$.  It
turns out that the default iBGP configuration, where every eBGP-speaking
router has an iBGP session with every other eBGP-speaking router in the
AS (\ie, a ``full mesh'' iBGP configuration, as described in
Section~\ref{sec:propagation}, Figure~\ref{fig:fullmesh}) satisfies
route validity.

\begin{figure}
\centering
\begin{psfrags}
%\epsfig{file=policy/figures/lemdr.eps,width=0.25\textwidth}
%
\psfrag{v_i}{{\LARGE $v_i$}}
\psfrag{v_j}{{\LARGE$v_j$}}
\psfrag{a}{{\LARGE $a$}}
\psfrag{b}{{\LARGE$b$}}
\psfrag{s}{{\LARGE$v_0$}}
%
%\hspace{-0.7in}
\resizebox{0.5\textwidth}{!}{\includegraphics{rlogic/figures/fm_validity.eps}}
\end{psfrags}
%\epsfig{file=policy/figures/dw.eps,width=0.28\textwidth}
\caption[The main idea of the proof of
  Theorem~\ref{th:mesh}]{This figure illustrates the main idea of the proof of
  Theorem~\ref{th:mesh}.  Dashed lines represent iBGP sessions, and
  solid line represent IGP links.  If routes $a$ and $b$ do not have equal
  local preference, AS path length, origin type, or MED, then $v_0$,
  $v_i$, and $v_j$ will all select the same route.  If these attributes
  are equal for both $a$ and $b$, then $v_0$ selects either $a$ or $b$
  depending on whether $v_i$ or $v_j$ has a shorter IGP path.  If $v_j$
  selects route $a$ and $v_i$ selects route $b$, then $v_0$'s shortest IGP
  path to the next hop corresponding to the chosen route must be direct.}
\label{fig:fm_validity}
\end{figure}


\begin{theorem}\label{th:mesh}
If an AS's iBGP configuration is a ``full mesh'' topology (\ie, where
every eBGP-speaking router has an iBGP session with every other router),
then iBGP does not violate route validity.
\end{theorem}

\begin{proof}
In a full mesh iBGP configuration, each router eventually learns of
the route selected by every eBGP-speaking router.  There are two
cases for any router $v_0$ in the AS: either (1)~$v_0$ selects a route via a
$v_i$ in a neighboring AS, or (2)~$v_0$ selects a $v_i$ in the same AS,
where $v_i$ in turn selects a route such that $v_{i+i}$ is in a
neighboring AS.  (The first case corresponds to a point-to-point eBGP
session; the second case corresponds to an iBGP session where the
route's next hop $v_i$ learned the route via a point-to-point eBGP
session but may be multiple IP hops away.)

Route validity holds in the first case, because $v_i$ is in a
neighboring AS, and, thus, selects a valid route by assumption.  In the
case where $v_i$ is in the same AS, the path $v_0, \ldots, v_i$ may
include multiple nodes (\ie, routers) in the same AS.  We know that
$v_i$ selects a valid route, because $v_i$ selects a route from a
neighboring AS and Theorem~\ref{thm:composable} applies.  Thus, it
remains to show that all routers on the path $v_0, \ldots, v_i$ select
the route $(d \rightarrow v_i)$.  Because all routers have an iBGP
session with every other router in the AS. All routers (and, in
particular, all routers along the path $v_0, \ldots, v_i$) learn the
same set of ``best'' routes.  Therefore, all of these routers would
select a route with the highest local preference, shortest AS path
length, lowest origin type, and lowest MED.  If some router on the path
$v_0, \ldots, v_i$, say $v_j$, selects a route with a next-hop in a
neighboring AS, then it must be the case that $v_0$ selects $(d
\rightarrow v_j)$, because this route has a shorter IGP path cost from
$v_0$ than $(d \rightarrow v_i)$, which is a contradiction.

Therefore, we know that all routers along the path $v_0, \ldots, v_i$
select {\em some} iBGP learned route with the shortest IGP path among
candidate iBGP routes.  Suppose that some router on this path $v_j$
selects a route other than $(d \rightarrow v_i)$, say $(d \rightarrow
v_k)$, because $v_j, \ldots, v_k$ has a shorter path cost than $v_j,
\ldots, v_i$.  Then $v_0, \ldots, v_k$ also has a
shorter IGP path cost than $v_0, \ldots, v_i$ and, hence, $v_0$ would also
select $(d \rightarrow v_k)$, which is a contradiction.
\end{proof}

\subsection{iBGP configurations with route reflection}

If a ``full mesh'' iBGP topology were the only possible configuration,
guaranteeing that iBGP satisfied route validity would be easy.
Unfortunately, as discussed in Section~\ref{sec:propagation}, this
technique does not scale to to large ASes because it requires $O(|R|^2)$
iBGP sessions, where $|R|$ is the number of routers in the AS.  As
previously described, large ASes typically use a technique called route
reflection, where a single route reflector selects a route on behalf of
its client routers.


\begin{figure}
\begin{center}
\begin{psfrags}
\psfrag{RR1}{{\LARGE $RR_1$}}
\psfrag{RR2}{{\LARGE $RR_2$}}
\psfrag{C1}{{\LARGE $C_1$}}
\psfrag{C2}{{\LARGE $C_2$}}
\psfrag{d}{{\LARGE $d$}}
%\centering\epsfig{file=rlogic/figures/dube.eps,width=0.7\textwidth}
\resizebox{0.5\textwidth}{!}{\includegraphics{rlogic/figures/dube.eps}}
\end{psfrags}
\end{center}
\caption[The interaction of IGP and route reflection can cause
  forwarding loops.]{The interaction of IGP and route reflection in iBGP
  can cause route validity violations resulting in forwarding loops.
  Note that this topology satisfies path visibility but not route
  validity.  Dashed lines represent iBGP sessions; a directed edge
  indicates an iBGP sessions from a route reflector to its client.}
\label{fig:dube}
\end{figure}


Guaranteeing route validity in an iBGP topology with route reflectors is
not easy.  Previous work has observed that the interactions between the
IGP topology and an iBGP topology with route reflectors can create route
validity violations~\cite{Dube99}.  Figure~\ref{fig:dube} shows one such
example.  Route reflectors $RR_1$ and $RR_2$ both receive a route to
destination $d$ and have clients $C_1$ and $C_2$ respectively.  Hence,
$C_1$ may receive and select the route $(d \rightarrow RR_1)$, and $C_2$
may receive and select the route $(d \rightarrow RR_2)$.  If the
shortest IGP path between $A$ and $RR_1$ is via $B$, and the shortest
IGP path between $B$ and $RR_2$ is via $A$, then traffic en route to $d$
that traverses either router $A$ or $B$ will be caught in a persistent
{\em forwarding loop}: that is, traffic destined for $d$ will never
reach $d$ but instead will instead repeatedly visit a cycle of two or
more nodes.  A forwarding loop is simply a special case of a route
validity violation and is defined as follows:

\begin{defn}[Forwarding loop]
A {\em forwarding loop} is a route validity violation where, given a
route at $v_0$, $(d \rightarrow v_i)$, some node $v_j$ on the path
segment $P = (v_0, v_1, \ldots, v_i)$ has a route $(d \rightarrow v_k)$
where $v_i \neq v_k$ and either the path segment $v_j, \ldots v_k$
(1)~contains a node $v_l\in P$ where $l<j$ or (2)~contains a node $v_l$
whose route to $d$ contains a forwarding loop.
\end{defn}

Ideally, it would be possible to detect whether a configuration of route
reflectors and clients satisfied route validity with a simple algorithm
that examined the static route reflector configurations.  Unfortunately,
it turns out that, given an iBGP topology where route reflector clients
may chose routes whose shortest IGP paths to the next-hop is not
guaranteed to be through their own route reflector, determining
whether route validity is satisfied is NP-complete.  We now formally
prove this result.  We first formally define the class of iBGP
topologies for which this result holds.

\begin{defn}[RR-IGP-Consistent]\label{defn:igp-consistent}
A route reflector configuration is {\em RR-IGP-Consistent} if the route
reflectors within that AS are configured such that every route reflector
is on all shortest IGP paths between its clients and the next hop nodes
for all routes received by those clients.
\end{defn}

\begin{theorem}\label{th:rr_np}
If a route reflector configuration is not {\em RR-IGP-Consistent}, then
verifying that iBGP satisfies route validity is NP-complete.
\end{theorem}

\begin{proof}
We will show that verifying route validity for an arbitrary route
reflector configuration is NP-complete by reduction from the directed
Hamiltonian cycle problem, DIRECTED-HAM-CYCLE.  Assume we have an
algorithm $\A$ that can verify route validity for an arbitrary
configuration of route reflectors and route reflector clients.  Then, we
can use $\A$ to solve DIRECTED-HAM-CYCLE.

Define the directed graph $\G = (C,E)$, where $C$ is the set of route
reflector clusters within a single AS, and a directed edge $E_i$ exists
from $u$ to $v$ if and only if the sequence $u,v$ exists in a
shortest IGP path between a node $v_0$ in some cluster $v\in C$ and a node
$w \in W$, where $W$ is the set of all egress routers in the AS.  That
is, the graph $\G$ will contain directed edges for shortest paths between
any route reflector cluster to any possible egress routers that may be
selected for routes from that cluster.

Note that, while any node in some $c\in C$ will select the same route
$(d\rightarrow w)$, routers in different clusters select egress routers
{\em independently}.  As opposed to the full mesh iBGP configuration,
where nodes along a path to an egress are guaranteed to select the
egress routers, nodes in different clusters have no such constraint.
Because a valid route may exist from $v_0$ to its next hop $w$ en route to
$d$ that is not the shortest path between those nodes, verifying route
validity involves showing that no node in $C$ is visited twice along the
path from any starting node in a cluster $c$ to any of its next hops
$w$, for all $c,w \in C$.

That is, to show that the path from a node any starting cluster $c \in
C$ eventually reaches any corresponding next hop $n \in V$ means that
the algorithm must visit the paths to $d$ starting from every cluster $c
\in C$ to every egress router in $W$.  However, an algorithm that did
this would be able to decide if $\G \in$ DIRECTED-HAM-CYCLE, since, by
the definition of $\G$, the algorithm traverses every path that exists in
the graph.
\end{proof}

Because detection of route validity violations is difficult in general,
some work has focused on defining sufficient conditions to guarantee
that iBGP does not violate route validity, such as requiring that iBGP
topologies be {\em RR-IGP-Consistent}.  In previous work, Dube suggested
placing route reflectors on the shortest IGP path to their
clients~\cite{Dube99}.  We now prove that this condition satisfies route
validity, provided that the AS's IGP satisfies route validity and all
paths between nodes within the same AS are policy-conformant.  Detecting
route validity faults in internal routing protocols is beyond the scope
of this dissertation, and service providers typically apply policies at
AS boundaries, rather than on paths within an AS.

\begin{theorem}\label{th:rr_safe}
If the route reflector configuration is {\em RR-IGP-Consistent} and the
iBGP configuration satisfies path visibility, then iBGP satisfies route
validity.
\end{theorem}

\begin{proof}
Assume that route validity is not satisfied.  Then there must exist a
destination $d$ and a path $P = (v_0, \ldots, v_n)$ for which some node $v_j$
between $v_0$ and $n$ selects a route $(d \rightarrow v_i)$, where $v_i
\neq n$.  There are two cases: (1)~$v_j$ is on the path from $v_0$ to the
route reflector of $v_0$; and (2)~$v_j$ is on the path from the route
reflector of $v_0$ to $n$.  

In the first case, if $v_0$ and $v_j$ select different next hops then, by
definition, they must be clients of different route reflectors.  Then,
it must be the case that either $v_0$'s path to $n$ goes through $v_j$'s
route reflector before its own route reflector, or vice versa, which is
a contradiction, since {\em RR-IGP-Consistent} is not satisfied.

The second case reduces to a similar argument as in
Theorem~\ref{th:mesh}: if $v_j$ selects a route with a next hop other
than $n$, then, because path visibility is satisfied, the route
reflector of $v_0$ would have also learned that route and selected it
(otherwise, $v_j$ would not have been on the route reflector's shortest
path to $n$, by the same argument as in Theorem~\ref{th:mesh}). 
%% Because we assume that IGP is valid, the path to every scope $1$
%% destination must be distance reducing; thus, a scope $1$ path that is
%% not valid must be a path to a destination-set containing at least two
%% scope $1$ destinations for some scope $0$ destination.  
%% But this is a contradiction---if the configuration is {\em
%% RR-IGP-Consistent}, then, for every scope $0$ destination, there is
%% exactly one scope $1$ destination for every scope $0$ destination.  If
%% this were not the case, then there must be some scope $1$ participant
%% which has a route reflector that is not on its shortest path.  Thus,
%% scope $1$ routing must satisfy route validity.
\end{proof}

Although this result is a helpful sufficient condition, it does not
guarantee that route validity will be satisfied when arbitrary links
fail, thus causing shortest IGP paths to change.  Designing an {\em
RR-IGP-Consistent} iBGP topology that is robust to link failures is a
difficult task.  Recent work has proposed using graph separators as a
way of efficiently placing route reflectors in an iBGP topology so as
not to violate route validity~\cite{Vutukuru2005}.  Another alternative
involves altering how route reflectors readvertise routes to their
clients, an option that we explore below.

\begin{defn}[RR-Reflect-All]
A route reflector configuration for an AS is {\em RR-Reflect-All} if all
route reflectors for that AS advertise all routes to a particular
destination (as opposed to simply the best route), and route reflectors
re-advertise all routes with each other (\ie, path visibility is
satisfied among router reflectors).
\end{defn}

\begin{theorem}\label{th:rr_reflect}
If the route reflectors in an AS are configured according to {\em
RR-Reflect-All}, then iBGP satisfies route validity.  
\end{theorem}

\begin{proof}
In an {\em RR-Reflect-All} iBGP configuration, all routers ultimately
receives all routes to a destination $d$.  There are two cases:
(1)~there exists only one route that is better according to the first
four steps of the BGP route selection process (local preference, AS path
length, 
origin type, MED); (2)~there exists more than one route to $d$, and ties
between multiple candidate routes are broken after the first four steps.
In the first case, all routers will select that single route with common
next hop, so route validity is satisfied because every router selects
the same next hop.  In the second case, either a router $v_0$ selects a
route via its own eBGP session, if one exists (in which case route
validity is trivially satisfied again) or it selects a route that
traverses other routers in the same AS to reach the next hop $n$.
Because every router receives all routes to a destination, if some
router on the shortest path between $v_0$ and $n$ selects a route with a
next-hop other than $n$, then $v_0$ would have also selected the route
with that next hop, by the same argument in Theorem~\ref{th:mesh}.
\end{proof}

An {\em RR-Reflect-All} configuration not only guarantees route
validity, but it also has the additional benefit of preventing certain
types of persistent route oscillation (a pathology we examine in more
detail in Section~\ref{sec:safety_def})~\cite{Basu2002}. Unfortunately,
implementing such a configuration in practice requires modifying
existing routers, which is not likely to happen.  Alternatively, an
architecture such as either the Routing Control Platform (RCP), which we
propose in Section~\ref{sec:rcp}, or the recent proposal for more
versatile route reflectors~\cite{id-versatile-rr}, could implement
an {\em RR-Reflect-All} configuration.  In lieu of these more
substantial architectural changes, techniques that analyze the static
router configurations from an AS (such as \rccns, presented in
Chapter~\ref{chap:rcc}) could determine whether an iBGP configuration
is fully meshed or satisfies {\em RR-IGP-Consistent} before the
configuration is deployed on a live network.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Path Visibility}\label{sec:visibility_def}

Path visibility says that if there exists one or more paths between two
nodes, then the routing protocol should propagate routes that give rise
to at least one of those paths.  Path visibility is an important
property for a number of reasons.  First, if a routing protocol
satisfies this property, then every node is guaranteed to have the
necessary information to reach all other nodes.
%Essentially, it states that the routing protocol is propagating
%enough information to allow any node to reach any other node for which
%it has a path in the underlying topology.  
Second, as is evident from the
theorems of Section~\ref{sec:validity_def}, an iBGP configuration must
satisfy path visibility in order to satisfy route validity.

\begin{defn}[Path visibility]
A routing protocol satisfies {\em path visibility} if, for all $v_0\in
V$ and for all destinations $d$, $\exists P = (v_0, \ldots, v_n, d)
\Rightarrow v_0$ learns a valid route $(d \rightarrow v_j)$ for some $0
\leq j \leq n$.
\end{defn}

Path visibility essentially states that if there exists a
policy-conformant path from $v_0$ to $d$, then $v_0$ should learn {\em at
least one} valid route to $d$.  Note that the definition does not
require $v_0$ to learn all routes to $d$, nor does it require that $v_0$
learn the ``best'' route to $d$ by any metric.  Path visibility also
does not require that the route that $v_0$ learns correspond to the actual
path that traffic takes from $v_0$ to $d$.  Although these might all be
desirable properties, path visibility only requires the minimal
conditions for correctness: as long as there is a policy-conformant path
from $v_0$ to $d$, the routing protocol should propagate information that
allows $v_0$ to send traffic to $d$.

By definition, path visibility violations result when some router fails
to propagate routes. These failures in route propagation sometimes
stem from mundane causes such as misconfigured filters (\ie, failing to
install or advertise routes for a policy-conformant path), but the way
iBGP propagates routes inside an AS can also cause path visibility
violations.  Recall from Section~\ref{sec:propagation} and
Figure~\ref{fig:ibgp_rr} that, by default, a router that selects a route
that it learned via iBGP will not typically readvertise that route over
any iBGP sessions, but a route reflector will readvertise routes learned
from one of its clients over all of its iBGP sessions and will
readvertise a route learned over any of its iBGP sessions to all of its
clients.  

\begin{figure}
\begin{center}
\begin{psfrags}
\psfrag{R1}{{\LARGE $RR_1$}}
\psfrag{R2}{{\LARGE $RR_2$}}
\psfrag{R3}{{\LARGE $RR_3$}}
\psfrag{X}{{\LARGE $C_1$}}
\psfrag{Y}{{\LARGE $C_2$}}
\psfrag{Z}{{\LARGE $C_3$}}
\resizebox{0.6\textwidth}{!}{\includegraphics{rlogic/figures/ibgp_rr_pv.eps}}
\end{psfrags}
\end{center}
\caption[A simple iBGP topology that violates path visibility.]{A simple
  iBGP topology that violates path visibility.  Routes learned via eBGP
  at $RR_1$ or $C_1$ will not be propagated to $RR_3$ or $C_3$ (and vice
  versa).}
\label{fig:rl:ibgp_rr}
\end{figure}


Because of the way iBGP readvertises routes, an arbitrary iBGP
configuration is not guaranteed to satisfy path visibility; missing iBGP
sessions of various types can cause violations.  In fact, even the very
simple iBGP topology in Figure~\ref{fig:rl:ibgp_rr} does not satisfy
path visibility: if the route reflector $RR_1$ (or its client, $C_1$
receives a route to some destination via an eBGP session, then neither
$RR_3$ nor $C_3$ will receive a route to the destination, and vice
versa.  It is imperative to determine the conditions on the iBGP
topology that guarantee path visibility.  We first consider iBGP
topologies without route reflection; then we consider the necessary and
sufficient conditions to guarantee path visibility for iBGP
configurations with route reflection.

Path visibility is important because it ensures that, if the network
remains connected at lower layers, the routing protocol does not create
any new partitions.  Path visibility reduces the likelihood of
suboptimal routing.  For example, in Figure~\ref{fig:rl:ibgp_rr}, even if
all clients learned {\em some} route to the destination via eBGP, the
clients would not be guaranteed to discover the {\em best} route to the
destination (\eg, if a client of the route reflector on the far left
learned a route with a shorter AS path, neither the route reflector on
the far right nor its clients would learn it).  As such, it is important
that an AS's iBGP configuration satisfy path visibility.  In the
remainder of this section, we derive the constraints on the iBGP
configuration that must be satisfied to guarantee path visibility.  We
first consider iBGP topologies that do not employ route reflection.

\begin{theorem}\label{th:mesh_visibility}
For an iBGP topology without route reflectors,
satisfying path visibility requires that every router have an iBGP
session with every router that may learn a route via eBGP (\ie, all
routers are ``fully meshed'' with the eBGP-speaking routers).
\end{theorem}

\begin{proof}
Consider a router $v_i$, which learns a route $r$ to some destination $d$ via
eBGP and a router $v_0$ within the same AS that does not have an iBGP
session to $v_i$.  Then, $v_i$ will readvertise $r$ to the routers to which
it has iBGP sessions, but none of those routers will advertise the route
to $v_0$, because they all learned the route via iBGP.
\end{proof}

Note that an iBGP configuration without route reflectors does {\em not}
require every router to have an iBGP session with every other router (as
is commonly stated): the routers that do not receive any routes to a
destination via eBGP need not have iBGP sessions with each other.


In large networks, a subset of the routers are configured as {\em route
reflectors}, with the configuration specifying a set of other routers as
{\em route reflector clients}.  A route reflector may itself be a client
of another route reflector.  Any router may also have ``normal'' (\ie,
peer) iBGP sessions with other routers.  We use the set of
reflector-client relationships between routers in an AS to define a
graph $G$, where each router is a node and each session is either a
directed or undirected edge: a client-reflector session is a directed
edge from client to reflector, and peer iBGP sessions are undirected
edges. We say that $G$ is {\em acyclic} if $G$ has no sequence of
directed and undirected edges that form a cycle.  In typical iBGP
hierarchy designs, $G$ is acyclic (previous work states that $G$ should
be acyclic to prevent protocol oscillations~\cite{Griffin2000}, although
we will see in Section~\ref{sec:safety_def} that this constraint is
unnecessary).  We now define the topological constraints on $G$ to
guarantee path visibility.


\begin{theorem}\label{thm:vis}
Suppose that the graph defined by an AS's iBGP relationships, $G$, is acyclic. 
Then, $G$ does not have a signaling partition if, and only if, the BGP
routers that are not route reflector clients form a clique.
\end{theorem}

\begin{proof}
Call the set of routers that are not reflector clients the
``top layer'' of $G$.  If the top layer is not a clique,
then there are two routers $X$ and $Y$ with no iBGP session between
them, such that no route learned using eBGP at $X$ will ever be
disseminated to $Y$, since no router readvertises an
iBGP-learned route.

Conversely, if the top layer is a clique, observe that {\em if} a
route reflector 
has a route to the destination, then all of its clients
have a route as well.  Thus, if every router in the
top layer has a route, all routers in the AS will have a route.  If any
router in the top layer learns a route through eBGP, then all the
top layer routers will hear of the route (because the top layer is a
clique).  Alternatively, if no router at the top layer hears an
eBGP-learned route, but some other router in the AS does, then that
route propagates up a chain of route reflectors (each client sends it to
its reflector, and the reflector sends it on all its iBGP sessions) to
the top layer, from there to all the other top layer routers, and from
there to the other routers in the AS.
\end{proof}

The results in this section suggest that path visibility can be
guaranteed by checking relatively simple constraints on the iBGP
topology, which can be determined by analyzing the static configuration
files alone.  Although, in the long run, architectural changes could be
made to guarantee that no configuration ever violates path visibility,
relatively simple checks against routing configuration can guarantee
path visibility today.



\section{Safety}\label{sec:safety_def}

In this section, we discuss properties related to improving
predictability in Internet routing: {\em safety} and {\em determinism}.
Violations of both safety and determinism can prevent the routing
protocol from arriving at a stable route assignment.  We briefly provide
an informal definition of safety and defer a formal definition to
Chapter~\ref{chap:policy} (Definition~\ref{def:safety}).

\begin{defn}[Safety]
A routing protocol satisfies {\em safety} if and only if, given no
changes to available paths after time $t_0$, then, at some time $t > t_0$,
each node $v\in G$ selects some route $r$ and does not deviate from $r$.
\end{defn}

Safety is an important property because it guarantees that changes in
{\em routes} (\ie, routing update messages) correspond directly to
changes in available {\em paths}.  This invariant is important for
several reasons.  First, if the routing protocol causes routers to
change routes unnecessarily (\ie, when the paths are in fact stable),
the protocol itself may cause performance degradations, such as lost or
reordered packets.  Second, if routing changes do not correspond to
changes in the actual topology, then debugging the cause of an
oscillation becomes more difficult, because an operator cannot determine
whether routing changes reflect problems with infrastructure (\eg, flaky
or failing equipment) or the routing protocol itself.
%
Safety problems result from essentially two causes:
\begin{enumerate}
\itemsep=-1pt
\item conflicting route selections within the same AS, resulting from
  interactions between BGP route attributes and the IGP (iBGP safety)
\item conflicting rankings, resulting from conflicting policies between
  ASes (eBGP safety)
\end{enumerate}
In both cases, preventing safety violations is quite challenging.  The
rest of this section focuses on the constraints for guaranteeing safety
in iBGP.  Guaranteeing that eBGP satisfies safety requires either having
visibility into the rankings of ASes across the {\em global} system (not
a realistic requirement, since ASes typically insist on keeping their
rankings private) or placing restrictions on how each AS can specify
rankings and filters.  This problem is the focus of
Chapter~\ref{chap:policy}.

Safety violations in iBGP result from the fact that BGP does
not satisfy {\em determinism}.  Determinism essentially says that the
route each router ultimately selects should not depend on either (1)~the
order in which messages arrive or (2)~the presence or absence of routes
that would not be selected in the first place.  We formally define
determinism and explain why guaranteeing determinism is difficult in
practice.
\begin{defn}[Selection function]
A selection function at router $r$, $\lambda_r$, takes as input a set of
routes $R_d = \{r_1, \ldots, r_n\}$ to some destination $d$ and produces
a single route $r_i \in R_d$.  The route $r_i$ is often called the
router's ``best route'' to $d$.
\end{defn}

\begin{defn}[Determinism]\label{def:determinism}
A routing protocol satisfies {\em determinism} if, for all routers $r$
and all destinations $d$, if $r$ has a set of routes $R_d$ to $d$,
$\lambda_r(R_d)$ satisfies the following two properties:
\begin{enumerate}
\itemsep=-1pt
\item $\lambda_r(R_d) = \lambda_r(R'_d)$, where $R'_d$ is any subset of
  $R_d$ that includes $\lambda_r(\R_d)$, and
\item $\lambda_r(R_d)$ does not depend on the order in which the routes
  in $R_d$ arrived at router $r$.
\end{enumerate}
Note that determinism of the routing protocol is property of the
selection function, $\lambda_r$, for all routers $r$.  Thus, we may also
discuss a single selection function, $\lambda_r$, in terms of whether it
satisfies determinism.
%% Let $\Sigma(R_d) = \{\sigma_1(R_d), \ldots, \sigma_{n!}(R_d)\}$ as
%% the set of all permutations of $R_d$ (\ie, the set of all possible
%% arrival orders for the candidate routes to $r_d$.
%% %
%% Let $T(R_d) = \{t_1(R_d), \ldots, t_{2^n}(R_d)\}$ be the set of all
%% subsets of $R_d$. 
%% %
%% Then, determinism is satisfied if and only if, for all $r_i \in
%% R_d$, $\lambda_r(R_d) = r_i \Rightarrow (r_i \in t_i(R_d) \Rightarrow
%% \lambda_r(\sigma_i(t_i(R_d))) = r_i)$, for all $\sigma_i \in \Sigma(R_d),
%% t_i \in T(R_d)$.
\end{defn}

In other words, if a router $r$ selects a certain route as its best
route from a set of candidate routes, then it should {\em always} select
that route if other routes are removed from that candidate set, and it
should always select that route regardless of the order in which
those routes arrive at router $r$.
Determinism is important for predictability, but, perhaps more
importantly, violations of determinism can induce safety violates
(even if the selection function of only one router violates
determinism).  


\begin{figure}
\centering
\begin{psfrags}
\psfrag{R1}{{\Large $R_1$}}
\psfrag{R2}{{\Large $R_2$}}
\psfrag{1}{$1$}
\psfrag{2}{$2$}
\psfrag{A}{$A$}
\psfrag{B}{$B$}
\psfrag{C}{$C$}
\psfrag{r1}{$\lambda_{R_1}(\{A,B\}) = A$; $\lambda_{R_1}(\{A,C\}) = C$}
\psfrag{r2}{$\lambda_{R_2}(\{A,B, C\}) = C$;  $\lambda_{R_2}(\{B,C\}) = B$}
\psfrag{A/P}{$A/\phi$}
\psfrag{B/C}{$B/C$}
%
\hspace{-0.4in}
\resizebox{0.7\textwidth}{!}{\includegraphics{rlogic/figures/det_a.eps}}
\end{psfrags}
%\epsfig{file=policy/figures/dw.eps,width=0.28\textwidth}
\caption[How determinism violations can cause safety
  violations.]{$\lambda_{R_2}$ does not satisfy determinism.  This violation
  can causes this routing system to oscillate.}
\label{fig:determinism}
\end{figure}


\begin{figure}
\centering
\begin{psfrags}
\psfrag{R1}{{\Large $R_1$}}
\psfrag{R2}{{\Large $R_2$}}
\psfrag{R3}{{\Large $R_3$}}
\psfrag{1}{$1$}
\psfrag{2}{$2$}
\psfrag{3}{$3$}
\psfrag{A}{$A$}
\psfrag{B}{$B$}
\psfrag{C}{$C$}
\psfrag{r1}{$\lambda_{R_1}(\{A,C\}) = C$;  $\lambda_{R_1}(\{A,B\}) = A$}
\psfrag{r2}{$\lambda_{R_2}(\{A,B, C\}) = C$;  $\lambda_{R_2}(\{B,C\}) = B$}
\psfrag{A/P}{$A/\phi$}
\psfrag{B/C}{$B/C$}
%
\hspace{-1.5in}
\resizebox{0.7\textwidth}{!}{\includegraphics{rlogic/figures/det_b.eps}}
\end{psfrags}
%\epsfig{file=policy/figures/dw.eps,width=0.28\textwidth}
\caption[Instantiation of Figure~\ref{fig:determinism} in a BGP
  configuration.]{Instantiation of Figure~\ref{fig:determinism} in a BGP
  configuration.  Router $1$ is a route reflector with two clients, $R_2$
  and $R_3$.  Costs on edges are IGP path costs.  Router $R_2$ prefers route
  $B$ over route $C$ due to a tiebreak.}
\label{fig:determinism_bgp}
\end{figure}

\begin{observation}
If the selection function of even one router, $\lambda_r$, violates
determinism, then the routing system may also violate safety.
\end{observation}

\noindent
The following example illustrates this point.

\begin{example}\label{ex:med_det}
Consider Figure~\ref{fig:determinism}.  Router $R_1$ selects route $A$
given the choices $\{A, B\}$ and selects route $C$ given choices
$\{A,C\}$. Note that this function, as specified, satisfies determinism.
On the other hand, router $R_2$'s selection function violates determinism:
$\lambda_{R_2}(\{A,B,C\}) = C$, but $\lambda_{R_2}(\{B,C\}) = B$.  The
interaction of this nondeterministic selection function, $\lambda_{R_2}$,
and  creates the following oscillation:
\begin{enumerate}
\itemsep=-1pt
\item Router $R_1$ receives only route $A$, selects it, and
  advertises this route to router $R_2$.
\item Router $R_2$ has received $\{A,B,C\}$, selects
  route $C$, and advertises it to router $R_1$.
\item Router $R_1$ has received $\{A,C\}$, selects
  route $C$, and sends a withdrawal ($\phi$) for route $A$ to router
  $R_2$. 
\item Router $R_2$ selects $B$ from the set $\{B,C\}$ and advertises it to
  router $R_1$, which implicitly withdraws route $C$. 
\item Router $R_1$ now has to select a route from the set $\{A,B\}$, selects
  route $A$, and advertises it to router $R_2$.
\end{enumerate}
This process repeats forever.

\subsection{Determinism Violations in BGP: The MED Attribute}

It turns out that this scenario can occur in BGP, because the MED
attribute causes each router's selection function to violate
determinism.  The addition of a third router, as shown in
Figure~\ref{fig:determinism}, gives rise to the oscillation from the
previous example.  In this case, router $R_1$ is a route reflector for
two clients: routers $R_2$ and $R_3$, with IGP costs as shown.  Routes
$A$ and $B$ are advertised by the same AS, and route $A$ has a lower MED
value.  In this setup, the selection functions are exactly as described
in the abstract example above: when router $R_2$ learns $\{A,B,C\}$,
route $B$ is eliminated due to MED, and route $C$ is selected because it
is an eBGP-learned route.  When router $R_2$ learns only $\{B,C\}$, on
the other hand, it prefers route $B$ over route $C$ due to the router ID
tiebreak.  Similarly, router $R_1$ prefers route $C$ over route $A$ due
to IGP, but router $A$ over router $B$ due to MED.
\end{example}

As the above example shows, the interaction between the MED attribute in
the BGP route selection process and route reflection can cause safety to
be violated.  Note that this example satisfies the guidelines that were
specifically proposed to avoid these types of
oscillations~\cite{rfc3345}.  Even though not all safety violations are
caused by violations of determinism, eliminating BGP's determinism
problem can eliminate all oscillations that do not involve cyclic
preferences over routes caused caused by setting the local preference
attribute.  Specifically, by making the MED attribute comparable across
{\em all} routes, rather than just those from the same AS, each router's
selection function can be made to satisfy determinism.  We now formally
show these two results.

\begin{lemma}\label{lem:det_med}
If every router's selection function compares the MED attribute across
all routes to a destination (rather than just across those from the same
neighboring AS), then iBGP satisfies determinism. 
\end{lemma}

\begin{proof}
If a router's selection function compares the MED attribute across all
routes, then it can compare all route attributes across all routes.
Suppose that $\lambda_r(R_d) = \rho_i$ for one order in which the routes
at $R_d$ are received, but $\lambda_r(R_d) = \rho_j$ for some other
arrival order, and $\rho_i \neq \rho_j$.  Then, in the first case, it
must be the case that router $R$ selected some route $\rho_k$ that was
better than $\rho_j$ but worse than $\rho_i$; in the latter case, router
$r$ must have selected some route $\rho_l$ that was more preferred than
route $\rho_i$ but less preferred than route $\rho_j$ based on some
route attribute.  But this scenario is impossible, because it suggests
that $\rho_i$ is more preferred than $\rho_j$, either due to the same
route attribute that $\rho_k$ was preferred over $\rho_j$ or by one
earlier in the selection process, and vice versa, which is a
contradiction.

A similar argument can be used to show that comparing the MED attribute
across all routes will satisfy $\lambda_r(R_d) = \rho_i \Rightarrow
\lambda_r(R'_d) = \rho_i$ for any $R'_d$ that is a subset of $R_d$ and
contains $R_i$. Suppose that $\lambda_R(R_d) = \rho_i$, but
$\lambda_r(R'_d) = \rho_j$, where $\rho_i \neq \rho_j$.  Then, it must
be the case that some $\rho_k$ that is in $R_d$ but not in $R'_d$ was
more preferred than $\rho_j$ but less preferred than $\rho_i$.  Because
all routes are comparable across all attributes, transitivity of
preferences would imply that $\rho_i$ would be more preferred than
$\rho_j$ for any set of routes containing both $\rho_i$ and $\rho_j$.
%: if both selections were made based on the same route
%attribute, then the scenario implies that $r_i$ and $r_j$ are both
%better and worse than each other, based on the same route attribute,
%which is a contradiction.  Suppose that $r_k$ were selected over $r_j$
\end{proof}

We explore how comparing the MED attribute across all routes affects
protocol operation, as well as how this might be done in practice, in
Section~\ref{sec:sandbox:med_disc}.  In short, the primary benefit of
making the route selection function deterministic a set of routers {\em
within a single domain} may violate safety if determinism is not
satisfied.  Although determinism prevents safety violations such as
those shown in Figures~\ref{fig:determinism}
and~\ref{fig:determinism_bgp}, it does not prevent {\em all} violations
of safety.  For that, we require a stronger notion of determinism, which
we call {\em egress determinism}.


\subsection{Egress Determinism Violations in BGP: Route Reflection}

Even if determinism is satisfied, an AS's iBGP topology can still induce
safety violations.  In particular, we can construct an oscillation that
involves the interaction between an AS's route reflector topology and
its IGP topology.  To better understand this interaction, we first
define a notion of {\em egress determinism}.  Egress determinism is a
stronger condition than determinism, as shown in
Figure~\ref{fig:determinism_venn}; essentially, it states that, given a
set of routes learned at {\em any} egress router in the AS, a routers
preference between any pair of those routes should not depend on either
the order in which those routes arrive or the presence or absence of
other routes.  Egress determinism implies determinism, but it also
states that every router's selection function should satisfy determinism
for all routes learned at {\em any} router in the AS, not just those
learned locally at that router.

\begin{figure}
\centering
\begin{psfrags}
\resizebox{0.4\textwidth}{!}{\includegraphics{rlogic/figures/det_venn.eps}}

\end{psfrags}
%\epsfig{file=policy/figures/dw.eps,width=0.28\textwidth}
\caption[The relationship between determinism, egress determinism, and
  safety.]{The relationship between determinism, egress determinism, and
  safety.} 
\label{fig:determinism_venn}
\end{figure}


\begin{defn}[Egress Determinism]\label{def:egress_determinism}
A routing protocol satisfies {\em egress determinism} if, for any router
$r$ in an AS that receives a set of routes $E_d$ to all destination $d$
{\em at all egress routers}, $\lambda_r(E_d)$ satisfies the following
two properties:
\begin{enumerate}
\itemsep=-1pt
\item $\lambda_r(E_d) = \lambda_r(E'_d)$, where $E'_d$ is any subset of
  $E_d$ that includes $\lambda_r(E_d)$, and
\item $\lambda_r(E_d)$ does not depend on the order in which the routes
  in $E_d$ arrived at router $r$.
\end{enumerate}
\end{defn}

\begin{figure}
\centering
\begin{psfrags}
%
\psfrag{x}{{\LARGE $x$}}
\psfrag{y}{{\LARGE$y$}}
\psfrag{z}{{\LARGE $z$}}
\psfrag{X}{{\LARGE $X$}}
\psfrag{Y}{{\LARGE $Y$}}
\psfrag{Z}{{\LARGE $Z$}}
\psfrag{R1}{{\LARGE $R_1$}}
\psfrag{R2}{{\LARGE $R_2$}}
%
%\hspace{-0.7in}
\resizebox{0.6\textwidth}{!}{\includegraphics{rlogic/figures/det_violation_rr.eps}}

\end{psfrags}
%\epsfig{file=policy/figures/dw.eps,width=0.28\textwidth}
\caption[The interaction of IGP and iBGP can cause a violation of egress
  determinism.]{The interaction of IGP and iBGP can cause a violation of egress
  determinism. $\lambda_{R_1}$ is equal to either $x$ or $y$ depending
  on whether $z \in E_d$.}
\label{fig:det_violation_rr}
\end{figure}


If every router in the AS always saw all routes in $E_d$, then
violations of egress determinism would never cause oscillations: given a
fixed set of routes $E_d$, every router would always see that set and
select the same route.  In an iBGP topology with route reflectors,
however, most routers will see some subset of $E_d$, which means that
violations of egress determinism can cause safety violations.  Consider
Figure~\ref{fig:det_violation_rr}; $X$ is a route reflector client of
$R_1$, and $Y$ and $Z$ are clients of route reflector $R_2$. Suppose
that routers $X$, $Y$, and $Z$ all potentially learn routes to some
destination $d$ with identical route attributes, causing routers within
the pictured AS to resort to preferring eBGP routes over iBGP routes,
and, that being equal, to prefer routes with the shortest IGP path cost.
If $E_d = \{x,y,z\}$, then $\lambda_{R_1}(E_d) = x$: $R_2$ selects $z$
due to its shorter IGP path cost to the next hop, and $R_1$, having
learned $x$ and $z$, selects route $x$.  If, on the other hand, $E_d =
\{x,y\}$, then $\lambda_{R_1}(E_d) = y$: $R_2$ selects $y$, and $R_1$,
having learned both $x$ and $y$, selects $y$ due to the shorter IGP path
cost. Thus, the first condition of egress determinism is violated.

\begin{figure}
\centering
\begin{psfrags}
%
\psfrag{R1}{{\LARGE $R_1$}}
\psfrag{R2}{{\LARGE $R_2$}}
\psfrag{R3}{{\LARGE $R_3$}}
\psfrag{x}{{\LARGE $x$}}
\psfrag{y}{{\LARGE $y$}}
\psfrag{z}{{\LARGE $z$}}
\psfrag{r1}{{\LARGE $\lambda_{R_1}(\{x,y\}) = y$;
    $\lambda_{R_1}(\{x,y,z\}) = x$}}
\psfrag{r2}{{\LARGE $\lambda_{R_2}(\{x,z\}) = z$;
    $\lambda_{R_2}(\{x,y,z\}) = x$}} 
\psfrag{r3}{{\LARGE $\lambda_{R_3}(\{y,z\}) = z$;
    $\lambda_{R_3}(\{x,y,z\}) = y$}}
\psfrag{x/y}{{\LARGE $x/y$}}
\psfrag{y/z}{{\LARGE $y/z$}}
\psfrag{x/z}{{\LARGE $x/z$}}
%
\hspace{-0.7in}
\resizebox{0.85\textwidth}{!}{\includegraphics{rlogic/figures/abstract_sd.eps}}

\end{psfrags}
%\epsfig{file=policy/figures/dw.eps,width=0.28\textwidth}
\caption{Violations of egress determinism can also cause safety violations.}
\label{fig:abstract_sd}
\end{figure}


Like determinism violations, egress determinism violations can cause
safety violations.  Consider the set of three routers whose ranking
functions violate egress determinism,
as shown in Figure~\ref{fig:abstract_sd};
$R_1$'s selection function is identical to that in
Figure~\ref{fig:det_violation_rr}. Each router prefers one route or the
other depending on the presence or absence of a third route.  In this
case, there is no stable assignment of routes $x$, $y$, and $z$ to
routers $R_1$, $R_2$, and $R_3$.  For example, if $R_1$ selects $x$,
then $R_2$ selects $z$ and $R_3$ selects $y$, prompting $R_1$ to select
$y$, and so on.  This very scenario can be realized in BGP
today if three router's route selection functions fail to satisfy egress
determinism, as shown in Figure~\ref{fig:sd_violation_rr_osc}.


\begin{figure}[t]
\centering
\begin{psfrags}
%
\psfrag{x}{{\LARGE $x$}}
\psfrag{y}{{\LARGE$y$}}
\psfrag{z}{{\LARGE $z$}}
\psfrag{X}{{\LARGE $X$}}
\psfrag{Y}{{\LARGE $Y$}}
\psfrag{Z}{{\LARGE $Z$}}
\psfrag{R1}{{\LARGE $R_1$}}
\psfrag{R2}{{\LARGE $R_2$}}
\psfrag{R3}{{\LARGE $R_3$}}
%
%\hspace{-0.7in}
\resizebox{0.6\textwidth}{!}{\includegraphics{rlogic/figures/sd_violation_rr_osc.eps}} 

\end{psfrags}
%\epsfig{file=policy/figures/dw.eps,width=0.28\textwidth}
\caption[The interaction of IGP and iBGP can cause a violation of egress
  determinism]{The interaction of IGP and iBGP can cause a violation of egress
  determinism that induces a safety violation.  This figure shows the
  instantiation of Figure~\ref{fig:abstract_sd} in BGP.  Previous work has
  also observed that violations of this type could occur~\cite{Griffin2002}
  but did not observe that these could be constructed in general by
  composing egress determinism violations.}
\label{fig:sd_violation_rr_osc}
\end{figure}



\begin{lemma}\label{lem:det_igp}
If an AS's iBGP topology is {\em RR-IGP-Consistent}, and every router's
selection function satisfies determinism, then iBGP satisfies egress
determinism.
\end{lemma}

\begin{proof}
Suppose that there exists some router $R$ such that
$\lambda_R(\{x,y,z\}) = x$, but $\lambda_R(\{x,y\}) = y$.  Because we
know that $\lambda_R$ satisfies determinism, it must be the case that
some router $C$ in the iBGP topology withdraws the eBGP-learned route
$x$ from router $R$ upon learning the eBGP-learned route $z$, thereby
causing the effective disappearance of $x$ at $R$.  Because $R$ selects
another route $y$, other than the route that caused the disappearance at
$R$, we also know that $C$ must have selected $z$ over $x$ because it
had a shorter IGP path to the router from which it learned $z$ (if the
selection were based on some other attribute such as AS path length,
$R$ would have also selected the route $z$, rather than $y$).  But $R$
now selects $y$, implying that its IGP path to the router that
learned $y$ is shorter than its path to the router that learned $z$
but longer than the path to the router that learned $x$.  This is only
possible if $R$ is not on the shortest path between $C$ and the egress
router that learned route $x$.  
\end{proof}

We now state the conditions for iBGP to satisfy safety using our results
involving determinism and egress determinism.  Specifically, we show
that if MED is compared across all routes (\ie, every router's selection
function satisfies determinism) and if every shortest path is a valid
iBGP signaling path (\ie, egress determinism is satisfied), then iBGP
satisfies safety.

\begin{theorem}\label{th:always_compare}
If the MED attribute is compared across all routes and every shortest
IGP path is a valid iBGP signaling path, then iBGP satisfies safety.
\end{theorem}

\begin{proof}
The proof follows from Lemmas~\ref{lem:det_med} and~\ref{lem:det_igp}.
If the conditions of the theorem hold, then BGP satisfies both
determinism and egress determinism.  It remains to show that no iBGP
topology can violate safety if it satisfies both determinism and egress
determinism.  

For simplicity, we will consider an iBGP route reflector hierarchy with
one level.  The argument can be extended to a multiple-level hierarchy,
and to a network with multiple top-level routers or multiple clients per
route reflector, without loss of generality.  Consider the possible
propagation of BGP routes between routers $c_1$ and $c_2$ and their
route reflectors $r_1$ and $r_2$.  Suppose $c_1$ and $c_2$ initially
select routes via eBGP; each will readvertise these routes to $r_1$ and
$r_2$.  Now, there are three possibilities: (1)~$r_1$ prefers the route
through its client $c_1$; (2)~$r_1$ prefers its own eBGP-learned route
(analogously for $r_2$); (3)~$r_1$ prefers a route via $r_2$ or $c_2$
(analogously for $r_2$).

In the first case, $r_1$'s selection of the route through $c_1$ will
obviously not cause either $r_1$ or $c_1$ to switch paths.  In the
second case, $c_1$ learns a route via $r_1$. If it continues to prefer
its own route, neither router will select a new route. If, on the other
hand, it prefers the route through $c_2$, then it will withdraw its
eBGP-learned route from $r_1$.  However, since $\lambda_{r_1}$ satisfies
determinism, $r_1$ will continue to select its own eBGP-learned route
when it receives this withdrawal.  In the third case, a similar argument
can be used to show that neither $r_1$ nor $c_1$ will select a new route
once $r_1$ selects a route via $c_1$.  For the third case, we must also
show that $r_1$'s withdrawal of either its own route or the route via
$c_1$ from $r_2$ will cause neither $r_2$ nor $c_2$ to change routes.
Since $r_1$ prefers a route via $r_2$ this means that $r_2$ selected its
own route or the route via $c_2$; egress determinism guarantees that
$r_1$'s withdrawal will not cause either $c_2$ or $r_2$ to change its
route selection.
\end{proof}

We note that our definitions have allowed us to derive sufficient
conditions on safety that are significantly weaker than those stated in
previous work~\cite{Griffin2000}.  In particular, {\em our results show
that assuming the relationships between route reflectors and their
clients are acyclic is unnecessary} (although a cyclic topology may make
an oscillation more likely in the event that egress determinism is
violated).  It would appear that the only way for a cyclic iBGP topology
to cause oscillations would be for either some shortest path to exist
that was not a valid signaling path, or for some IGP edges to have
negative edge weights.

\begin{figure}
\centering
\begin{psfrags}
%
\psfrag{x}{{\LARGE $x$}}
\psfrag{y}{{\LARGE$y$}}
\psfrag{z}{{\LARGE $z$}}
\psfrag{X}{{\LARGE $X$}}
\psfrag{Y}{{\LARGE $Y$}}
\psfrag{Z}{{\LARGE $Z$}}
\psfrag{R1}{{\LARGE $R_1$}}
\psfrag{R2}{{\LARGE $R_2$}}
\psfrag{R3}{{\LARGE $R_3$}}
\psfrag{l1}{{\LARGE $l_1$}}
\psfrag{l2}{{\LARGE $l_2$}}
\psfrag{l3}{{\LARGE $l_3$}}
\psfrag{l4}{{\LARGE $l_4$}}
\psfrag{l5}{{\LARGE $l_5$}}
\psfrag{l6}{{\LARGE $l_6$}}
%
%\hspace{-0.7in}
\resizebox{0.7\textwidth}{!}{\includegraphics{rlogic/figures/ibgp_cycle.eps}} 

\end{psfrags}
%\epsfig{file=policy/figures/dw.eps,width=0.28\textwidth}
\caption[When iBGP violates safety but satisfies determinism
  and egress determinism, the only way a cyclic iBGP topology can
  violate safety is if the IGP allows negative edge weights.]{When iBGP
  violates safety but satisfies determinism 
  and egress determinism, the only way a cyclic iBGP topology can
  violate safety is if the IGP allows negative edge weights.  This
  example shows an iBGP hierarchy that includes only six routers, but it
  generalizes: $R_i$ could be any cyclic relationship at the top of the
  hierarchy, $X$ could be a path through a sequence of iBGP sessions to
  the egress router $X$ (\eg, a sequence of route reflector-client
  sessions) and $l_4$ could be the cost of that path, and so forth.}
\label{fig:ibgp_cycle}
\end{figure}



To understand why cycles do not cause problems if the all shortest paths
are valid signaling paths, see Figure~\ref{fig:ibgp_cycle}.  In this
example, if both determinism and egress determinism are satisfied, then
the only case where an oscillation might result is where $R_1$ prefers
route $y$ over route $x$, $R_2$ prefers route $z$ over $y$, and $R_3$
prefers $x$ over $z$.  All other cases where oscillation might occur
(\ie, those caused by violations of egress determinism) require some
shortest IGP path between a router and an egress not be a valid iBGP
signaling path.  For safety to be violated in the first place in this
example, routes $x$, $y$, and $z$ must all have equal local preference,
AS path length, origin type and MED (otherwise, all routers would select
the most preferable route or routes).  Presuming that all routes are
equally good up to the step in route selection involving the IGP
tiebreak, then the only way for such a situation to occur is if the
following inequalities were satisfied:
\begin{eqnarray*}
l_1 + l_4 & < & l_6 \\
l_2 + l_5 & < & l_4 \\
l_3 + l_6 & < & l_5 
\end{eqnarray*}
which implies that $l_1 + l_2 + l_3 < 0$, or that some IGP edge weights
must be negative.

Theorem~\ref{th:always_compare} is significant because
the conditions on the iBGP topology that are required to guarantee
safety are identical those for guaranteeing route validity, as stated in
Theorem~\ref{th:rr_safe}.  Furthermore, as there are now known
techniques for {\em generating} these
configurations~\cite{Vutukuru2005}, our results are prescriptive, since
this technique that was designed to generate iBGP topologies that
guarantee route validity also happens to generate topologies that
guarantee safety.

This section has described safety violations that result from
protocol interactions within a single AS.  However, safety is a somewhat
unique property because it inherently depends on how different ASes are
allowed to rank candidate routes to a destination.  Whereas, in iBGP, a
router's rankings are inherently constrained by the underlying IGP
topology, in eBGP, an AS's rankings can be essentially arbitrary.
Verifying a property that inherently involves analyzing the interactions
between the configurations of multiple ASes is troubling,
because these ASes compete with one another, no single AS has knowledge 
of the configurations of other ASes.  Chapter~\ref{chap:policy} explores
how safety can be guaranteed {\em across multiple ASes} without
requiring each AS to expose its configurations to other ASes.


\section{Summary}

Detecting problems in Internet routing first requires a precise
specification of correct behavior and framework for reasoning about
whether that specification is satisfied.  This chapter has presented
three specifications for correctness---route validity, path visibility,
and safety---explained why each of these properties is important for the
fundamental operation of Internet routing, and reasoned about how these
properties may be satisfied or violated in the context of BGP.
Expressing a correctness specification in terms of high-level properties
is a necessary first step in reasoning about the behavior of an Internet
routing protocol.  

In the subsequent chapters of this dissertation, we will exploit this
correctness specification in two ways.  First, we will use the
specification as a set of constraints that to guide the operations and
design of correct Internet routing.  Specifically,
Theorems~\ref{th:mesh}, \ref{th:rr_safe}, \ref{th:mesh_visibility},
and~\ref{thm:vis} 
suggest invariants on configuration that could be verified by detecting
when the configuration violates certain invariants, and
Theorems~\ref{th:rr_reflect} and~\ref{th:always_compare} suggest
possible protocol modifications.  Chapter~\ref{chap:rcc} focuses
specifically on detecting violations of these invariants against BGP
configuration.  Second, we will use the specification as a building
block for algorithms that assume that these properties are satisfied in
the first place.  Chapter~\ref{chap:sandbox} develops algorithms for
computing the routes selected by each BGP-speaking router within an AS,
without simulation; these algorithms assume as preconditions that iBGP
satisfies both path visibility and safety.
