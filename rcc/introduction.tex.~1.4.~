%\section{Introduction}

\cs{T}his chapter describes the design, implementation, and evaluation of
\textbf{\rccns},
the router configuration checker, a tool
that uses static analysis to detect faults in Border Gateway Protocol
(BGP) 
configuration.  
By finding faults over a
distributed set of router configurations, \rcc enables network
operators to test and debug configurations before deploying them in an
operational network. This approach improves on the status quo of
``stimulus-response'' debugging where operators need to run
configurations in an operational network before finding faults.



%Router configuration languages
%offer considerable flexibility to network operators, who use them
Network operators use router configurations
to provide 
reachability, express routing policy (\eg, transit and peering
relationships~\cite{Norton2000}, inbound and outbound
routes~\cite{Beijnum2002}, etc.), configure primary and backup
links~\cite{Gao2001b}, and perform traffic engineering across multiple
links~\cite{Feamster2004}.  
%It is a tribute to the designers and
%implementors of BGP that it can meet these important practical
%requirements while ensuring that competing Internet Service Providers
%(ISPs) can cooperate to achieve global connectivity.
%
%Unfortunately, the complexity of Internet routing in real-world
%operation leads to a number of fragilities.  
%
%The behavior of wide-area Internet routing depends heavily on how BGP
%routers are configured.  
Configuring a network of BGP routers is like
writing a distributed program where complex feature interactions
occur both within one router and across multiple routers.  This
complex process is exacerbated by the number of lines of code (we find
that a 500-router network typically has more than a million lines
of configuration), by
configuration being distributed across the routers in the network, by the
absence of useful high-level primitives in today's configuration
languages, by the diversity in vendor-specific configuration
languages, and by the number of ways in which the same high-level
functionality can be expressed in a configuration language.  
As a result, router configurations are complex and
faulty~\cite{Beijnum2002,Mahajan2002}.   

Faults in BGP configuration can seriously affect
end-to-end Internet connectivity,
leading to lost packets, forwarding loops,
and unintended paths.  
Configuration faults include
invalid routes (including hijacked and leaked routes); 
contract violations~\cite{Feamster2004b}; unstable
routes~\cite{labovitz:ton01}; routing
loops~\cite{Dube99,Feamster2003b}; and persistently oscillating
routes~\cite{Basu2002,Griffin99,Varadhan2000}.  
Section~\ref{s:nanogproblems} discusses the 
problems observed in operational networks in detail.
We find that \rcc can detect many of these
configuration faults.

%Network operators
%specify configuration settings in commercial routers using proprietary
%domain-specific languages that embody hundreds of options (\eg, the
%median length of router configurations was about 2,000 lines, with each
%configuration ranging from 45 lines to over 12,000 lines).  


%Operators configure today's commercial routers using low-level
%primitives, and router configuration involves complicated feature
%interactions both within one router and across multiple routers.  This
%low-level process prevents a network operator from getting a
%high-level view of the network or performing basic sanity checks,
%which makes router configuration extremely error-prone.

Detecting BGP configuration faults poses several challenges.
%
First, 
defining a correctness specification for 
BGP is difficult: its many modes of operation and myriad tunable
parameters permit
a great deal of flexibility in both the design of a network and in how that
design is implemented in the configuration itself.
Second, this high-level correctness specification must be used to derive
a set of constraints that can be tested against the actual
configuration.
%
Finally, BGP configuration is distributed---analyzing
how a network configuration behaves requires both synthesizing
distributed configuration fragments and representing the configuration
in a form that makes it easy to test constraints.
%
This chapter tackles these challenges and makes the following
three contributions:

First, we define two high-level aspects of correctness---{\em path visibility}
and {\em route validity}---and use this specification to derive
constraints that can be tested against
the BGP configuration.  Path
visibility says that BGP will correctly propagate routes for existing,
usable IP-layer paths; essentially, it states that the control
path is propagating BGP routes correctly.  Route validity says that, if
routers attempt to send data packets via these routes, then packets
will ultimately reach their intended destinations.

Second, we present the design and implementation of {\bf \rccns}.
\rcc focuses on detecting faults that have the potential to cause {\em
  persistent} routing failures.  \rcc is not concerned with
correctness during convergence (since any distributed protocol will
have transient inconsistencies during convergence).  \rccns's goal is
to detect problems that may exist in the steady state, even when the
protocol converges to some stable outcome.
%; thus, it
%assumes that
%the protocol will converge to some outcome, given stable inputs.

%\rcc has helped many operators
%debug their existing BGP configurations and can potentially help network
%operators debug their configurations {\em before} deploying them.


%(1)~originate incorrect
%routes, (2)~propagate incorrect routes, (3)~fail to propagate routes
%when it should, (4)~violate intended high-level policy, and (5)~exhibit
%nondeterministic behavior.  
%We define invariants that should hold at each stage of BGP route
%propagation and derive constraints
%under which those invariants will be violated.
%We apply these insights to the design of \rccns.

%This paper develops a framework for analyzing BGP configurations
%and presents several contributions:
%\begin{enumerate}
%\itemsep=-1pt
%%
%\item Building on previous work~\cite{Feamster2003b}, we define 
%{\em correctness constraints} for BGP configuration that can be tested
%with static analysis.  \rccns's tests are
%neither complete (\ie, they may not find all configuration errors) nor
%sound (\ie, they may report problems that are simply deviations from best
%common practice), but they are rich enough to capture many potentially
%catastrophic errors. 
%%In the process, we also present several aspects
%%of BGP correctness that cannot be checked with static
%%analysis.
%%
%\item We use these constraints to design and implement {\bf \rccns}
%(``router configuration checker''), a tool that analyzes router
%configurations and detects anomalies.  \rcc has helped many operators
%debug their existing BGP configurations and can potentially help network
%operators debug their configurations {\em before} deploying them.
%%
%\item We use \rcc to {\em explore the extent of real-world BGP
%  misconfigurations}.  Although misconfiguration has previously been
%  studied both analytically and in measurement studies, this paper presents
%  the first direct analysis of BGP configuration from real-world ISPs. This
%  analysis and our conversations with operators help us understand {\em
%  why} various problems occur.
%% and determine whether common problems result from
%%  weaknesses in BGP or problems with specifying configuration.
%%
%%These insights allow us to recommend
%%specific changes both to BGP and to configuration languages.  
%%As the protocols and configuration
%%languages for wide-area routing evolve, we believe that the ability to
%%detect and fix errors in configuration before deployment will be
%%invaluable to network operators.
%\end{enumerate}

%%First, \rcc can help network operators running today's
%%networks cope with the increasing complexity of wide-area routing and
%%reduce the number of errors observed in practice.  
%%We believe that some changes to BGP and configuration languages are
%%necessary, and we offer some recommendations.  


Third, we use \rcc to explore the extent of real-world BGP
configuration faults; this chapter presents the first published analysis
of BGP configuration faults in real-world ISPs.  
We have analyzed real-world,
deployed configurations from 17 different ASes and detected more than
1,000 BGP configuration faults that had previously gone undetected by
operators.  These faults ranged from simple ``single router'' faults
(\eg, undefined variables) to complex, {\em network-wide} faults
involving interactions between multiple routers.  
To date, \rcc has been downloaded by over 65 network operators.

Although
\rcc is actually intended to be used {\em before} configurations are
deployed,
\rcc discovered many faults that could potentially cause failures in
live, operational networks.
These include: (1) faults that could have caused network partitions due
to errors in how external BGP information was being propagated to
routers inside an AS, (2) faults that cause invalid routes to propagate
inside an AS, and (3) faults in policy expression that caused routers to
advertise routes (and hence potentially forward packets) in a manner
inconsistent with the AS's desired policies.  
%
Our findings indicate that configuration faults that can
cause serious failures are often not immediately apparent (\ie, the
failure that results 
from a configuration fault may only be triggered by a specific failure
scenario or sequence of route advertisements).  If \rcc were used before
BGP configuration was deployed, we expect that it would be able to
detect many immediately active faults.

Our analysis of real-world configurations suggests that
%there are many reasons for
%configuration errors, but three reasons explain 
most configuration faults stem from three main causes.  First, the
mechanisms for propagating routes within a network are overly complex.
The main techniques used to propagate routes scalably within a network
(\eg, ``route reflection with clusters'') are easily misconfigured.
Second, many configuration faults arise because
configuration is distributed
across routers: even simple policy specifications require configuration
fragments on multiple routers in a network.  Third,
configuring policy often involves low-level mechanisms (\eg, ``route maps'',
``community lists'', etc.)  that should be hidden from network
operators.
%Finally, operators lack a systematic process for configuring functions such as
%filtering.
%{\bf XXX last two points above are not strong or compelling or clear.}
%; better configuration management
%tools.
%Some large networks
%perform rudimentary configuration checks~\protect\cite{Caldwell2003},
%but the coverage of these tests could be improved using a tool like
%\rccns.

%% Our analysis suggests that most BGP configuration errors happen for
%% three main reasons (and several other minor reasons).  First, BGP is
%% complex, and, until now, no framework has existed for reasoning about
%% BGP's correctness; therefore, {\bf XXX this next sentence is NOT a
%% reason for the error; re-word!}  First many errors go unnoticed simply
%% because operators don't realize that anything is wrong in the first
%% place.  Second, BGP's configuration languages require specification of
%% simple policy in terms of complex, low-level mechanisms and several
%% levels of indirection, which makes mistakes more likely.  Finally, the
%% ad hoc process by which most operators configure BGP leaves much room
%% for inconsistencies and errors.

The rest of this chapter proceeds as follows. Section~\ref{s:background}
provides background on BGP configuration.
Section~\ref{sec:rcc_overview} describes the design of \rccns.
Sections~\ref{sec:visibility} and~\ref{sec:validity} discuss \rccns's path
visibility and route validity tests.  Section~\ref{sec:implementation} 
describes implementation details.  Section~\ref{sec:evaluation}
presents configuration faults that \rcc discovered in 17
operational networks,
and Section~\ref{s:rcc_concl} concludes.

 
%% ; these errors are summarized in
%% Table~\ref{tab:errors} in Section~\ref{sec:evaluation}.  Several vendors
%% have expressed interest in incorporating some of \rccns's correctness
%% checks at configuration time.

%% Our study of BGP configuration also presents important insights
%% regarding the ways in which BGP can violate correctness.  Using the
%% properties and rules routing logic from previous
%% work~\cite{Feamster2003b}, we present a systematic way of making
%% assertions about BGP's correctness.  In the process, we discover many
%% interesting properties about how BGP works today.  We derive several
%% theoretical results that make checking BGP's correctness easier today
%% and suggest ways to improve the BGP protocol and decision process.  As
%% part of our analysis of configuration errors, we also classify the types
%% of errors that are best fixed with protocol modifications versus fixes
%% to the configuration language.

%% This paper offers several new contributions:
%% \begin{enumerate}
%% \itemsep=-2pt
%% \item We present a framework for verifying BGP's correctness.
%% \item We apply this framework to the design and implementation of a
%%   tool that uses static analysis to verify BGP configuration
%%   correctness.  Our tool has helped operators debug real-world BGP
%%   configuration.  
%% \item We present our findings on BGP configuration errors and anomalies
%%   from static analysis of real-world BGP configurations.  {\em This
%%   paper is the first paper to explore BGP configuration errors using
%%   analysis of real-world BGP configuration files.}
%% \item Based on our analysis, we suggest concrete ways to improve BGP's
%%   correctness properties.  In particular, we distinguish errors that
%%   should be fixed with protocol modifications from those that should be
%%   fixed with a better configuration language.
%% \end{enumerate}


%% The rest of the paper is structured as follows.
%% Section~\ref{sec:related} provides background information on BGP,
%% previously observed and reported configuration errors, and
%% relevant previous work.  Section~\ref{sec:analysis} proposed a framework
%% for reasoning about BGP's correctness and uses this framework to
%% analyze how BGP's configuration can go wrong (as well as what can and
%% can't be done about it).  Section~\ref{sec:design} presents the analysis
%% of \rcc, and Section~\ref{sec:evaluation} presents our experience with
%% the tool in practice.  
%% We conclude in Section~\ref{sec:conclusion}.
%\item logic + static analysis is useful for finding errors
%\item tasks operators want to perform boil down to a handful.  suggests
%  the need for language constructs
%\item eBGP: specification problems, best fixed by language
%  improvements.  iBGP: protocol problems, best fixed by replacing iBGP


%% Researchers and
%% network operators are quick to point out that BGP has many shortcomings
%% and suggest that BGP should be redesigned or replaced.  We can address
%% BGP's problems with a combination of one or more of the following
%% techniques: 
%% \begin{itemize}
%% \itemsep=-1pt
%% \item augmenting the configuration language with higher-level
%%   correctness checks,
%% \item changing the configuration language, and
%% \item changing the protocol itself.
%% \end{itemize}



%Rather than view BGP
%as a (traditional) routing protocol whose only goal is to provide
%loop-free connectivity, we take the view that BGP's flexible
%configuration makes it more like a {\em distributed program}.  This
%viewpoint is substantiated by the observation that many observed
%problems result from the interaction between different configuration
%options and the interaction between different routers that have
%inconsistent configurations.

%Because the Internet is a heterogeneous network that comprises many
%competing ASes, BGP (or any interdomain routing protocol, for that
%matter) must be configurable.  Network operators configure BGP to
%perform a variety of tasks, from interdomain traffic
%engineering to configuring backup
%links.  Additionally, each AS has complex
%relationships with its neighboring ASes, including peering,
%customer-provider, sibling, or some combination of these.  BGP's
%flexible configuration options enable it to accomplish a variety of
%tasks but cause it to behave incorrectly if a network operator makes a
%mistake; thus, BGP verification requires anaylzing how it is
%configured.

%% In this paper, we present a BGP verification tool called {\em \rcc}
%% (Routing Lexer) that checks BGP configuration for anomalies and errors
%% using static analysis. \fixme{more details here about how we solve these
%% challenges; logic, etc.} We use our tool to analyze the BGP
%% configurations of several large ISPs and discover the types of errors
%% that appear in practice.



%\begin{enumerate}

%\item Why it's hard:
%\begin{itemize}
%% \item place where the problem occurs may be very different from where
%%   the problem manifests itself
%% \item need to consider interaction between configs on multiple routers
%% \item interactions b/w eBGP and iBGP/IGP
%% \item protocol problems vs. specification problems
%\item logistical: getting our hands on real configs
%\end{itemize}

%% \item Many possible approaches
%% \begin{itemize}
%% \item ``band-aids'' to existing protocol and language (\eg, correctness
%%   checkers)  
%% \item replace/change/constrain protocol
%% \item replace/change/constrain language
%% \end{itemize}

%\item Contributions
%\end{enumerate}


%% Our work demonstrates that viewing BGP as a {\em distributed program}
%% expressed using router configurations can help resolve some of the
%% issues raised above.  
